"""
    Creates constraints that can be passed to the MPC for collision avoidance. This node needs to be called inside the house.py node, because 
    it collects positions and dimensions of the obstacles as they are generated by house.py.
"""

import numpy as np
import matplotlib.pyplot as plt

class ObstacleConstraintsGenerator:
    def __init__(self, robot_dim: list, scale: float) -> None:
        self.walls = []
        self.doors = []
        self.furnitures = []
        self.constraints = []
        self.vectors = {}
        self.points = {}
        self.robot_dim = robot_dim*scale # to be used to construct constraints later
        self.constraints = []
        self.robot_pos = 0
        self.normals = []
        self.vertices = []
        self.sides = []
        self.surfaces = []
        self.vertices_open = []

    def generateConstraintsCylinder(self) -> np.ndarray:
        """
            Generate constraints for obstacles, output is the an array of offsets of each side of each obstacle
            and an array of normals for every side. 
        """
        self.normals = []
        self.vertices = []
        self.constraints = []
        self.sides = []

        self.generateConstraints(obstacles=self.walls, obstacles_name='walls')
        self.generateConstraints(obstacles=self.doors, obstacles_name='doors')
        self.generateConstraints(obstacles=self.furnitures, obstacles_name='furnitures')

        self.constraints = np.array(self.constraints)
        self.normals = np.array(self.normals).reshape(-1, 2)
        self.surfaces = np.array(self.surfaces).reshape(-1, 2, 2)

        return self.constraints, self.normals

    def computeNormalVector(self, p1: list[float, float], p2: list[float, float]) -> list[float, float]:
        """
            Returns the normal vector of the line defined by points p1 and p2, all pointing to the center of the obstacles.
        """
        dx = p2[0] - p1[0]
        dy = p2[1] - p1[1]

        return [dy, -dx], [-dy, dx] # [dy, -dx] -> left and top side of obstacle, [-dy, dx] -> right and lower side of the obstacle
    
    def getVertices(self):
        """
            Get vertices of all the obstacles, and append floor and ceiling vertices to close the space. This is used for
            ellipsoid.
        """
        self.vertices = []
        self.computeVertices(obstacles=self.walls, obstacles_name='walls')
        self.computeVertices(obstacles=self.doors, obstacles_name='doors')
        self.computeVertices(obstacles=self.furnitures, obstacles_name='furnitures')
        self.vertices = np.array(self.vertices)
        self.vertices_open = self.vertices
        ceiling_height = 1
        floor_trt = [np.max(self.vertices[:, :, 0]), np.max(self.vertices[:, :, 1]), -0.1]
        floor_tlt = [np.min(self.vertices[:, :, 0]), np.max(self.vertices[:, :, 1]), -0.1]
        floor_blt = [np.min(self.vertices[:, :, 0]), np.min(self.vertices[:, :, 1]), -0.1]
        floor_brt = [np.max(self.vertices[:, :, 0]), np.min(self.vertices[:, :, 1]), -0.1]

        floor_trb = [np.max(self.vertices[:, :, 0]), np.max(self.vertices[:, :, 1]), 0]
        floor_tlb = [np.min(self.vertices[:, :, 0]), np.max(self.vertices[:, :, 1]), 0]
        floor_blb = [np.min(self.vertices[:, :, 0]), np.min(self.vertices[:, :, 1]), 0]
        floor_brb = [np.max(self.vertices[:, :, 0]), np.min(self.vertices[:, :, 1]), 0]

        ceiling_trt = [np.max(self.vertices[:, :, 0]), np.max(self.vertices[:, :, 1]), ceiling_height+0.1]
        ceiling_tlt = [np.min(self.vertices[:, :, 0]), np.max(self.vertices[:, :, 1]), ceiling_height+0.1]
        ceiling_blt = [np.min(self.vertices[:, :, 0]), np.min(self.vertices[:, :, 1]), ceiling_height+0.1]
        ceiling_brt = [np.max(self.vertices[:, :, 0]), np.min(self.vertices[:, :, 1]), ceiling_height+0.1]

        ceiling_trb = [np.max(self.vertices[:, :, 0]), np.max(self.vertices[:, :, 1]), ceiling_height]
        ceiling_tlb = [np.min(self.vertices[:, :, 0]), np.max(self.vertices[:, :, 1]), ceiling_height]
        ceiling_blb = [np.min(self.vertices[:, :, 0]), np.min(self.vertices[:, :, 1]), ceiling_height]
        ceiling_brb = [np.max(self.vertices[:, :, 0]), np.min(self.vertices[:, :, 1]), ceiling_height]

        floor_vertices = [floor_trb, floor_tlb, floor_blb, floor_brb, floor_trt, floor_tlt, floor_blt, floor_brt]
        ceiling_vertices = [ceiling_trb, ceiling_tlb, ceiling_blb, ceiling_brb, ceiling_trt, ceiling_tlt, ceiling_blt, ceiling_brt]
        self.vertices = list(self.vertices)
        self.vertices.append(floor_vertices)
        self.vertices.append(ceiling_vertices)
        self.vertices = np.array(self.vertices)
        return np.array(self.vertices)

    def computeVertices(self, obstacles, obstacles_name: str):
        """
            Compute the vertices of a given set of obstacles, accounting for their orientations.
        """
        # Compute all vertices
        for obstacle in obstacles:
            if obstacles_name=='furnitures' or np.abs(obstacle['theta']) != np.pi/2:
                # Compute the corner locations and center of each side
                tl = [obstacle['x'] - obstacle['width']/2, obstacle['y'] + obstacle['length']/2, 0]
                tr = [obstacle['x'] + obstacle['width']/2, obstacle['y'] + obstacle['length']/2, 0]
                br = [obstacle['x'] + obstacle['width']/2, obstacle['y'] - obstacle['length']/2, 0]
                bl = [obstacle['x'] - obstacle['width']/2, obstacle['y'] - obstacle['length']/2, 0]

                tlt = [obstacle['x'] - obstacle['width']/2, obstacle['y'] + obstacle['length']/2, obstacle['height']]
                trt = [obstacle['x'] + obstacle['width']/2, obstacle['y'] + obstacle['length']/2, obstacle['height']]
                brt = [obstacle['x'] + obstacle['width']/2, obstacle['y'] - obstacle['length']/2, obstacle['height']]
                blt = [obstacle['x'] - obstacle['width']/2, obstacle['y'] - obstacle['length']/2, obstacle['height']]

                if obstacles_name == 'furnitures':
                    tl = [obstacle['x'] - obstacle['width']/2, obstacle['y'] + obstacle['length']/2, obstacle['z']]
                    tr = [obstacle['x'] + obstacle['width']/2, obstacle['y'] + obstacle['length']/2, obstacle['z']]
                    br = [obstacle['x'] + obstacle['width']/2, obstacle['y'] - obstacle['length']/2, obstacle['z']]
                    bl = [obstacle['x'] - obstacle['width']/2, obstacle['y'] - obstacle['length']/2, obstacle['z']]

                    tlt = [obstacle['x'] - obstacle['width']/2, obstacle['y'] + obstacle['length']/2, obstacle['z']+obstacle['height']]
                    trt = [obstacle['x'] + obstacle['width']/2, obstacle['y'] + obstacle['length']/2, obstacle['z']+obstacle['height']]
                    brt = [obstacle['x'] + obstacle['width']/2, obstacle['y'] - obstacle['length']/2, obstacle['z']+obstacle['height']]
                    blt = [obstacle['x'] - obstacle['width']/2, obstacle['y'] - obstacle['length']/2, obstacle['z']+obstacle['height']]
            else:
                tl = [obstacle['x'] - obstacle['length']/2, obstacle['y'] + obstacle['width']/2, 0]
                tr = [obstacle['x'] + obstacle['length']/2, obstacle['y'] + obstacle['width']/2, 0] 
                br = [obstacle['x'] + obstacle['length']/2, obstacle['y'] - obstacle['width']/2, 0] 
                bl = [obstacle['x'] - obstacle['length']/2, obstacle['y'] - obstacle['width']/2, 0] 

                tlt = [obstacle['x'] - obstacle['length']/2, obstacle['y'] + obstacle['width']/2, obstacle['height']]
                trt = [obstacle['x'] + obstacle['length']/2, obstacle['y'] + obstacle['width']/2, obstacle['height']]
                brt = [obstacle['x'] + obstacle['length']/2, obstacle['y'] - obstacle['width']/2, obstacle['height']]
                blt = [obstacle['x'] - obstacle['length']/2, obstacle['y'] - obstacle['width']/2, obstacle['height']]
            
            # Append vertices
            vertices = [tl, tr, br, bl, tlt, trt, brt, blt]
            self.vertices.append(vertices)

    def generateConstraints(self, obstacles, obstacles_name: str) -> np.ndarray:
        """
            Compute the offsets and normals of each surface for a given set of obstacles.
        """
        vectors = []
        points = []
        for obstacle in obstacles:
            # Set center of the obstacle
            center = np.array([obstacle['x'], obstacle['y']])

            # Compute the center points of the sides of each obstacle, accounting for their orientation
            # Unless the obstacle is a furniture, then it does not have orientation
            if obstacles_name=='furnitures' or np.abs(obstacle['theta']) != np.pi/2:
                # Compute the corner locations and center of each side
                tl = [obstacle['x'] - obstacle['width']/2, obstacle['y'] + obstacle['length']/2, 0]
                tr = [obstacle['x'] + obstacle['width']/2, obstacle['y'] + obstacle['length']/2, 0]
                br = [obstacle['x'] + obstacle['width']/2, obstacle['y'] - obstacle['length']/2, 0]
                bl = [obstacle['x'] - obstacle['width']/2, obstacle['y'] - obstacle['length']/2, 0]

                left_point = [center[0] - obstacle['width']/2, center[1]]
                top_point = [center[0], center[1] + obstacle['length']/2]
                right_point = [center[0] + obstacle['width']/2, center[1]]
                bot_point = [center[0], center[1] - obstacle['length']/2]
            else:
                tl = [obstacle['x'] - obstacle['length']/2, obstacle['y'] + obstacle['width']/2, 0]
                tr = [obstacle['x'] + obstacle['length']/2, obstacle['y'] + obstacle['width']/2, 0]
                br = [obstacle['x'] + obstacle['length']/2, obstacle['y'] - obstacle['width']/2, 0]
                bl = [obstacle['x'] - obstacle['length']/2, obstacle['y'] - obstacle['width']/2, 0]

                left_point = [center[0] - obstacle['length']/2, center[1]]
                top_point = [center[0], center[1] + obstacle['width']/2]
                right_point = [center[0] + obstacle['length']/2, center[1]]
                bot_point = [center[0], center[1] - obstacle['width']/2]

            # Compute the normal vectors on each side
            left_norm = np.array(self.computeNormalVector(bl, tl)[0])
            top_norm = np.array(self.computeNormalVector(tl, tr)[0])
            right_norm = np.array(self.computeNormalVector(br, tr)[1])
            bot_norm = np.array(self.computeNormalVector(bl, br)[1])

            # Transform to unit vectors
            left_norm = left_norm / np.linalg.norm(left_norm)
            top_norm = top_norm / np.linalg.norm(top_norm)
            right_norm = right_norm / np.linalg.norm(right_norm)
            bot_norm = bot_norm / np.linalg.norm(bot_norm)

            self.normals = np.append(self.normals, [left_norm, right_norm, top_norm, bot_norm])
            self.constraints = np.append(self.constraints, [left_norm@left_point, right_norm@right_point, top_norm@top_point, bot_norm@bot_point])
            self.surfaces.append([[left_point, left_norm], [right_point, right_norm], [top_point, top_norm], [bot_point, bot_norm]])
            vectors.append(center-left_point)
            vectors.append(center-right_point)
            vectors.append(center-top_point)
            vectors.append(center-bot_point)
            points.append(left_point)
            points.append(right_point)
            points.append(top_point)
            points.append(bot_point)

            self.vectors[obstacles_name] = vectors
            self.points[obstacles_name] = points        

    def display(self, pos) -> None:
        """
            To plot the normals in the room.

            Black lines are the walls
            Yellow lines are the doors
            Blue lines are the furnitures
            Green dots are the points on the side of the obstacles
        """
        print('plotting')
        self.robot_pos = pos
        active_walls = self.surfaces[self.act == 0]
        fig, ax = plt.subplots(figsize=(12, 7))
        ax.scatter(self.robot_pos[0], self.robot_pos[1], s=10, c='red')
        print(active_walls)

        if 'walls' in self.points.keys():
            for point, vec in zip(self.points['walls'], self.vectors['walls']):
                ax.arrow(point[0], point[1], vec[0], vec[1])
                ax.scatter(point[0], point[1], s = 10, c = 'green')

        
        if 'doors' in self.points.keys():
            for point, vec in zip(self.points['doors'], self.vectors['doors']):
                ax.arrow(point[0], point[1], vec[0], vec[1], color='yellow')
                ax.scatter(point[0], point[1], s = 10, c = 'green')

        if 'furnitures' in self.points.keys():
            for point, vec in zip(self.points['furnitures'], self.vectors['furnitures']):
                ax.arrow(point[0], point[1], vec[0], vec[1], color='blue')
                ax.scatter(point[0], point[1], s = 10, c = 'green')
        
        for wall in active_walls:
            ax.scatter(wall[0][0], wall[0][1], s = 10, c= 'red')
            
        ax.set_ylim([-4.5, 4.5])
        ax.set_xlim([-9, 6.5])
        plt.show()